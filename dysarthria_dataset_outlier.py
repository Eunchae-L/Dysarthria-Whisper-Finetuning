# -*- coding: utf-8 -*-
"""dysarthria_dataset_outlier.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1nWRz0yJ5CiIFyGkazI-DGTJZbpUdHwEJ

### Settings
"""

# 필요한 패키지 설치
!pip install datasets transformers torchaudio

import numpy as np
import pandas as pd
import os
import re
import warnings
import matplotlib.pyplot as plt
import seaborn as sns
import librosa
import librosa.display
from sklearn.preprocessing import minmax_scale
import IPython.display as ipd

plt.rcParams['figure.figsize'] = (20,8)
plt.rcParams['font.size'] = 16
sns.set_style('darkgrid')
warnings.filterwarnings("ignore")

# Google Colab에서 런타임 설정을 위해 드라이브 마운트
from zipfile import ZipFile
from google.colab import drive
drive.mount('/content/drive')

"""### Dataset Load"""

import os
import zipfile  # zipfile 모듈을 가져옵니다.

# 압축 파일 경로 (업로드한 파일의 경로에 따라 변경)
zip_file_path = '/content/archive.zip'
output_dir = '/content/dataset'

# 압축 해제
with zipfile.ZipFile(zip_file_path, 'r') as zip_ref:
    zip_ref.extractall(output_dir)

print("압축 해제가 완료되었습니다.")

# 데이터셋 구조 확인
for root, dirs, files in os.walk(output_dir):
    print(root, len(files), "개의 파일")

import os
import shutil

# Define the paths
source_path = "/content/dataset/archive/Dysarthria and Non Dysarthria"
destination_path = "/content/dataset/Dysarthria and Non Dysarthria"
archive_path = "/content/dataset/archive"
macosx_path = "/content/dataset/__MACOSX"

# Step 1: Move 'Dysarthria and Non Dysarthria' to the new location
try:
    if os.path.exists(source_path):
        shutil.move(source_path, destination_path)
        print(f"Moved '{source_path}' to '{destination_path}'.")
    else:
        print(f"Source path '{source_path}' does not exist.")
except Exception as e:
    print(f"Error moving '{source_path}': {e}")

# Step 2: Delete the empty 'archive' folder
try:
    if os.path.exists(archive_path):  # Check if empty
        shutil.rmtree(archive_path)
        print(f"Deleted folder: '{archive_path}'.")
    else:
        print(f"Folder '{archive_path}' is does not exist.")
except Exception as e:
    print(f"Error deleting folder '{archive_path}': {e}")

# Step 3: Delete the non-empty '__MACOSX' folder
try:
    if os.path.exists(macosx_path):
        shutil.rmtree(macosx_path)  # Remove the folder and all its contents
        print(f"Deleted folder and contents: '{macosx_path}'.")
    else:
        print(f"Folder '{macosx_path}' does not exist.")
except Exception as e:
    print(f"Error deleting folder '{macosx_path}': {e}")

import os

# 기존 폴더 경로와 새 폴더 경로 정의
old_folder_path = "/content/dataset/Dysarthria and Non Dysarthria"  # 기존 폴더 경로
new_folder_path = "/content/dataset/Dysarthria_and_Non_Dysarthria"  # 변경할 새 폴더 경로

# 폴더명 변경
try:
    os.rename(old_folder_path, new_folder_path)
    print(f"폴더명이 변경되었습니다: '{old_folder_path}' → '{new_folder_path}'")
except FileNotFoundError:
    print(f"오류: '{old_folder_path}' 경로가 존재하지 않습니다.")
except PermissionError:
    print("오류: 권한이 부족하여 폴더명을 변경할 수 없습니다.")
except Exception as e:
    print(f"예기치 못한 오류가 발생했습니다: {e}")

path = "/content/dataset/data_with_path.csv"
data = pd.read_csv(path)
data

data['Wav_path'] = data['Wav_path'].str.replace(
    '/kaggle/input/dysarthria-and-nondysarthria-speech-dataset/Dysarthria and Non Dysarthria',
    '/content/dataset/Dysarthria_and_Non_Dysarthria',
    regex=False
)

data['Txt_path'] = data['Txt_path'].str.replace(
    '/kaggle/input/dysarthria-and-nondysarthria-speech-dataset/Dysarthria and Non Dysarthria',
    '/content/dataset/Dysarthria_and_Non_Dysarthria',
    regex=False
)

import os
import pandas as pd

# 데이터셋 경로
output_dir = '/content/dataset'

# 실제 데이터셋의 Wav 파일 경로 수집
actual_wav_files = set()
for root, _, files in os.walk(output_dir):
    for file in files:
        if file.endswith('.wav'):  # Wav 파일만 필터링
            actual_wav_files.add(os.path.join(root, file).replace("\\", "/"))  # 경로 표준화

# Wav_path 열의 값과 실제 파일 경로 비교
data['Exists'] = data['Wav_path'].apply(lambda x: x in actual_wav_files)

# 존재하지 않는 경로가 있는 행 제거
missing_data = data[data['Exists'] == False]  # 존재하지 않는 행 추출
data = data[data['Exists']]  # 존재하는 경로만 유지
data = data.drop(columns=['Exists'])  # Exists 열 제거

# 결과 저장
cleaned_csv_path = '/content/dataset/cleaned_data_with_path.csv'
data.to_csv(cleaned_csv_path, index=False)

# 결과 출력
print(f"원본 데이터에서 제거된 행 개수: {len(missing_data)}")
print(f"정리된 CSV 파일이 저장되었습니다: {cleaned_csv_path}")

path = "/content/dataset/cleaned_data_with_path.csv"
data = pd.read_csv(path)
data

path = "/content/dataset/data_with_path.csv"
metadata = pd.read_csv(path)

metadata['label'] = metadata['Is_dy'].map({'No': 0, 'Yes': 1})  # Map labels to 0 and 1
metadata.drop(columns=['Is_dysarthria'], inplace=True)

def get_audio_features(file_path):
    try:
        y, sr = librosa.load(file_path, sr=None)
        duration = len(y) / sr
        return sr, duration
    except Exception as e:
        return None, None

metadata['sr'], metadata['duration'] = zip(*metadata['Wav_path'].apply(get_audio_features))

metadata.to_csv("metadata.csv", index=False)

path = "/content/dataset/data_with_path.csv"
metadata = pd.read_csv(path)

D_data = metadata[metadata['label'] == 1]
ND_data = metadata[metadata['label'] == 0]

D_data.describe()

"""### EDA
### Visualization Functions: Features and Plots¶

Waveplot

Spectrogram

Zero Crossing Rate

Spectral Centroids

Spectral Rolloff

MFCCs

Mel Spectrogram

##### Class 분포
"""

def plot_class_distribution(data):
    class_counts = data['label'].value_counts()
    plt.figure(figsize=(6, 4))
    class_counts.plot(kind='bar')
    plt.title("Class Distribution")
    plt.xlabel("Class")
    plt.ylabel("Number of Samples")
    plt.xticks(ticks=[0, 1], labels=['Dysarthria', 'Non-Dysarthria'])
    plt.show()

plot_class_distribution(metadata)

"""#### Audio Duration"""

def calculate_statistics(data):
    label_mapping = {0: 'Non-Dysarthria', 1: 'Dysarthria'}
    stats = data.groupby('label')['duration'].describe()
    stats.index = stats.index.map(label_mapping)
    return stats

def plot_boxplot(data):
    dysarthria_data = data[data['label'] == 1]
    plt.figure(figsize=(8, 6))
    sns.boxplot(y='duration', data=dysarthria_data, palette='Blues')
    plt.title("Audio Duration Boxplot for Dysarthria")
    plt.ylabel("Duration (seconds)")
    plt.show()

stats= calculate_statistics(metadata)
print("Basic Statistics:\n", stats)

plot_boxplot(metadata)

"""##### duration outlier 분석

Long duration Top10 outlier 확인
"""

top_10_largest_duration = D_data.nlargest(10, 'duration')
top_10_largest_duration[['Gender', 'Wav_path', 'duration']]

outlier1_path = top_10_largest_duration.iloc[0]['Wav_path']
outlier2_path = top_10_largest_duration.iloc[1]['Wav_path']
outlier3_path = top_10_largest_duration.iloc[2]['Wav_path']

ipd.Audio(outlier1_path.strip())

print(outlier1_path)
print(top_10_largest_duration.iloc[0]['Txt_path'])
print(top_10_largest_duration.iloc[0]['Prompts'])

ipd.Audio(outlier2_path.strip())

print(outlier2_path)
print(top_10_largest_duration.iloc[1]['Txt_path'])
print(top_10_largest_duration.iloc[1]['Prompts'])

ipd.Audio(outlier3_path.strip())

print(outlier3_path)
print(top_10_largest_duration.iloc[2]['Txt_path'])
print(top_10_largest_duration.iloc[2]['Prompts'])

outlier4_path = top_10_largest_duration.iloc[3]['Wav_path']
outlier5_path = top_10_largest_duration.iloc[4]['Wav_path']

print(outlier4_path)
print(top_10_largest_duration.iloc[3]['Txt_path'])
print(top_10_largest_duration.iloc[3]['Prompts'])

print(outlier5_path)
print(top_10_largest_duration.iloc[4]['Txt_path'])
print(top_10_largest_duration.iloc[4]['Prompts'])

"""Prompt가 .jpg로 끝나는 데이터들"""

jpg_data = D_data[D_data['Prompts'].str.endswith('.jpg', na=False)]
jpg_data

jpg_data.to_csv("jpg_data.csv", index=False)

bracket_data = D_data[D_data['Prompts'].str.contains(r'\[.*?\]', na=False)]
bracket_data

len(bracket_data)

bracket_data['Prompts'].unique()

starts_with_bracket = bracket_data[bracket_data['Prompts'].str.startswith('[', na=False)]
not_start_with_bracket = bracket_data[~bracket_data['Prompts'].str.startswith('[', na=False)]

starts_with_bracket['Prompts'].unique()

not_start_with_bracket['Prompts'].unique()

def plot_duration_distribution(data):
    plt.figure(figsize=(10, 6))

    min_duration = data['duration'].min()
    max_duration = data['duration'].max()

    for label, group in data.groupby('label'):
        plt.hist(group['duration'],
                 bins=np.linspace(min_duration, max_duration, 50),
                 alpha=0.5,
                 label='Dysarthria' if label == 1 else 'Non-Dysarthria',
                 edgecolor='black')
    plt.title("Audio Duration Distribution")
    plt.xlabel("Duration (seconds)")
    plt.ylabel("Frequency")
    plt.legend()
    plt.grid(axis='y', linestyle='--', alpha=0.7)
    plt.tight_layout()
    plt.show()

plot_duration_distribution(metadata)

D_data.isnull().sum()

def visualize_audio_difference(file_paths):
    plt.figure(figsize=(12, 6))

    for idx, (label, file_path) in enumerate(file_paths.items()):
        y, sr = librosa.load(file_path, sr=None)

        plt.subplot(2, 2, idx*2 + 1)
        librosa.display.waveshow(y, sr=sr)
        plt.title(f"Waveform - {'Dysarthria' if label == 0 else 'Non-Dysarthria'}")

        plt.subplot(2, 2, idx*2 + 2)
        S = librosa.feature.melspectrogram(y=y, sr=sr, n_mels=128)
        S_dB = librosa.power_to_db(S, ref=np.max)
        librosa.display.specshow(S_dB, sr=sr, x_axis='time', y_axis='mel')
        plt.title(f"Spectrogram - {'Dysarthria' if label == 0 else 'Non-Dysarthria'}")

    plt.tight_layout()
    plt.show()

"""#### Wavplot"""

def show_spectrogram(audio_path,label,gender):
    x , sr = librosa.load(audio_path)
    X = librosa.stft(x)
    Xdb = librosa.amplitude_to_db(abs(X))
    plt.figure(figsize=(20,6))
    librosa.display.specshow(Xdb, sr=sr, x_axis='time', y_axis='hz',cmap='plasma')
    plt.colorbar()
    plt.title(f"Spectrogram of Class: {label}, Gender: {gender}")

def show_zcr(audio_path,label,gender):
    x , sr = librosa.load(audio_path)
    zero_crossings = librosa.zero_crossings(x)
    print("Sum of zero crossing ", zero_crossings.sum())
    plt.figure(figsize=(20, 5))
    plt.title(f'Zero Crossing Rate of Class: {label}, Gender: {gender}')
    zcrs = librosa.feature.zero_crossing_rate(x)
    plt.plot(zcrs[0])
    plt.show()

def normalize(x, axis=0):
    return minmax_scale(x, axis=axis)

def show_spectral_centroids(audio_path,label,gender):
    plt.figure(figsize=(20, 5))
    plt.title(f'Spectral Centroids of Class: {label}, Gender: {gender}')
    x , sr = librosa.load(audio_path)
    spectral_centroids = librosa.feature.spectral_centroid(x, sr=sr)[0]
    frames = range(len(spectral_centroids))
    t = librosa.frames_to_time(frames)
    librosa.display.waveshow(x, sr=sr, alpha=0.4)
    plt.plot(t, normalize(spectral_centroids), color='r')
    plt.show()

def show_spectral_rolloff(audio_path,label,gender):
    plt.figure(figsize=(20, 5))
    plt.title(f'Spectral Rolloff of Class: {label}, Gender: {gender}')
    x , sr = librosa.load(audio_path)
    spectral_rolloff = librosa.feature.spectral_rolloff(x, sr=sr, roll_percent=0.01)[0]
    frames = range(len(spectral_rolloff))
    t = librosa.frames_to_time(frames)
    librosa.display.waveshow(x, sr=sr, alpha=0.4)
    plt.plot(t, normalize(spectral_rolloff), color='r')
    plt.show()

def show_mfccs(audio_path,label,gender):
    plt.figure(figsize=(20, 6))
    plt.title(f'MFCC of Class: {label}, Gender: {gender}')
    x , sr = librosa.load(audio_path)
    mfccs = librosa.feature.mfcc(y=x, sr=sr)
    librosa.display.specshow(mfccs, sr=sr, x_axis='time',cmap='plasma')
    plt.show()

def show_melspectro(audio_path,label,gender):
    plt.figure(figsize=(20, 6))
    plt.title(f'Mel Spectro of Class: {label}, Gender: {gender}')
    x , sr = librosa.load(audio_path)
    melspectro = librosa.feature.melspectrogram(y=x, sr=sr)
    librosa.display.specshow(melspectro, sr=sr, x_axis='time',cmap='plasma')
    plt.show()

data.sample(frac=1).reset_index(drop=True,inplace=True)
M_dysar = data[(data['Gender']=='Male') & (data['Is_dysarthria']=='Yes')].sample(1)
F_dysar = data[(data['Gender']=='Female') & (data['Is_dysarthria']=='Yes')].sample(1)
M_ndysar = data[(data['Gender']=='Male') & (data['Is_dysarthria']=='No')].sample(1)
F_ndysar = data[(data['Gender']=='Female') & (data['Is_dysarthria']=='No')].sample(1)

ipd.Audio(M_ndysar.iloc[0].Wav_path.strip())

def show_waveplot(audio_path,label,gender):
    x , sr = librosa.load(audio_path.strip())
    plt.figure(figsize=(20, 6))
    librosa.display.waveshow(x, sr=sr)
    plt.title(f"Waveplot: of Class: {label}, Gender: {gender}")

show_waveplot(M_dysar.iloc[0].Wav_path, M_dysar.iloc[0].Is_dysarthria, M_dysar.iloc[0].Gender)
show_waveplot(F_dysar.iloc[0].Wav_path, F_dysar.iloc[0].Is_dysarthria, F_dysar.iloc[0].Gender)
show_waveplot(M_ndysar.iloc[0].Wav_path, M_ndysar.iloc[0].Is_dysarthria, M_ndysar.iloc[0].Gender)
show_waveplot(F_ndysar.iloc[0].Wav_path, F_ndysar.iloc[0].Is_dysarthria, F_ndysar.iloc[0].Gender)

subset = data[(data['Gender'] == 'Female') & (data['Is_dysarthria'] == 'No')]
subset

import soundfile as sf
data, sr = sf.read("/content/dataset/Dysarthria_and_Non_Dysarthria/Dataset/Female_Non_Dysarthria/FC01/Session1/Wav/0001.wav")
print(f"Original Sampling Rate: {sr} Hz")

def plot_average_waveform(data, disease, gender):
  groups = data[gender].unique()
  plt.figure(figsize=(20, 10))

  sr = 16000
  for group in groups:
    for label in data[disease].unique():
      # 특정 그룹과 라벨의 데이터만 필터링
      subset = data[(data[gender] == group) & (data[disease] == label)]
      average_waveform = None

      for path in subset['Wav_path']:
        x, sr = librosa.load(path.strip(), sr=sr)
        if average_waveform is None:
          average_waveform = x
        else:
          # 파형을 누적하여 평균화 준비
          average_waveform = np.add(average_waveform, x)

          # 평균 파형 계산
        if average_waveform is not None:
          average_waveform /= len(subset)
          librosa.display.waveshow(average_waveform, sr=sr, alpha=0.6, label=f"{group}-{disease}")
    plt.title(f"Average Waveform by {gender} and {label}")
    plt.legend()
    plt.show()

plot_average_waveform(data, disease='Is_dysarthria', gender='Gender')

"""### 데이터 전처리

오류 데이터 제거

Outlier 제거

1. Female_dysarthria/F03/Session1/Wav/0118.wav

2. Male_Dysarthria/M03/Session2/Wav/0183.wav

3. Male_Dysarthria/M03/Session2/Wav/0331.wav

4. 'Prompts' 가 .jpg로 끝나는 데이터들

5. 'Prompts'가 [명령문]인 데이터들.
"""

path = "/content/dataset/cleaned_data_with_path.csv"
metadata = pd.read_csv(path)

metadata['label'] = metadata['Is_dysarthria'].map({'No': 0, 'Yes': 1})  # Map labels to 0 and 1
metadata.drop(columns=['Is_dysarthria'], inplace=True)

def get_audio_features(file_path):
    try:
        y, sr = librosa.load(file_path, sr=None)
        duration = len(y) / sr
        return sr, duration
    except Exception as e:
        return None, None

metadata['sr'], metadata['duration'] = zip(*metadata['Wav_path'].apply(get_audio_features))

D_data = metadata[metadata['label'] == 1]
ND_data = metadata[metadata['label'] == 0]

top_10_largest_duration = D_data.nlargest(10, 'duration')

outlier1_path = top_10_largest_duration.iloc[0]['Wav_path']
outlier2_path = top_10_largest_duration.iloc[1]['Wav_path']
outlier3_path = top_10_largest_duration.iloc[2]['Wav_path']
outlier4_path = top_10_largest_duration.iloc[3]['Wav_path']

D_data = D_data[~D_data['Wav_path'].isin([outlier1_path, outlier2_path, outlier3_path, outlier4_path])]
D_data = D_data[~D_data['Prompts'].str.endswith('.jpg', na=False)]
D_data = D_data[~D_data['Prompts'].str.startswith('[', na=False)]

def modify_prompt(prompt):
    if '[' in prompt:
        return prompt.split('[')[0].strip()
    return prompt

D_data.loc[
    D_data['Prompts'].str.contains(r'\[.*?\]', na=False),
    'Prompts'
] = D_data['Prompts'].apply(modify_prompt)

D_data.describe()

D_data

D_data.to_csv("data_with_path_cleaned.csv", index=False)

import os

def find_txt_files_with_jpg(root_dir):
    txt_files_with_jpg = []

    # 하위 디렉토리를 순회하며 .txt 파일 확인
    for subdir, dirs, files in os.walk(root_dir):
        for file in files:
            if file.endswith(".txt"):
                txt_file_path = os.path.join(subdir, file)
                try:
                    with open(txt_file_path, "r", encoding="utf-8") as f:
                        content = f.read()
                        if ".jpg" in content:  # .jpg 포함 여부 확인
                            txt_files_with_jpg.append(txt_file_path)
                except Exception as e:
                    print(f"Error reading {txt_file_path}: {e}")

    return txt_files_with_jpg

# 사용 예시
root_directory = "/content/dataset/Dysarthria and Non Dysarthria"
files_with_jpg = find_txt_files_with_jpg(root_directory)

# 결과 출력
if files_with_jpg:
    print("Found .txt files containing '.jpg':")
    for file_path in files_with_jpg:
        print(file_path)
else:
    print("No .txt files containing '.jpg' were found.")

"""# Non-Dysarthria"""

import numpy as np
import pandas as pd
import os
import re
import warnings
import matplotlib.pyplot as plt
import seaborn as sns
import librosa
import librosa.display
from sklearn.preprocessing import minmax_scale
import IPython.display as ipd

plt.rcParams['figure.figsize'] = (20,8)
plt.rcParams['font.size'] = 16
sns.set_style('darkgrid')
warnings.filterwarnings("ignore")

"""1. 오디오 파일 - txt 파일 로드
2. 상위 폴더 이름에서 분류 추출(F-M/ND-D)
3. 오디오 파일 path, txt 파일 path 추출
4. csv 파일에 저장(column=['Gender', 'Audio_path', 'Txt_path']
5. Metadata csv
- Audio duration

"""



"""txt가 .jpg인 파일 필터링"""

import os

def find_txt_files_with_jpg(root_dir):
    txt_files_with_jpg = []

    # 하위 디렉토리를 순회하며 .txt 파일 확인
    for subdir, dirs, files in os.walk(root_dir):
        for file in files:
            if file.endswith(".txt"):
                txt_file_path = os.path.join(subdir, file)
                try:
                    with open(txt_file_path, "r", encoding="utf-8") as f:
                        content = f.read()
                        if ".jpg" in content:  # .jpg 포함 여부 확인
                            txt_files_with_jpg.append(txt_file_path)
                except Exception as e:
                    print(f"Error reading {txt_file_path}: {e}")

    return txt_files_with_jpg

# 사용 예시
root_directory = "/content/dataset/Dysarthria and Non Dysarthria"
files_with_jpg = find_txt_files_with_jpg(root_directory)

# 결과 출력
if files_with_jpg:
    print("Found .txt files containing '.jpg':")
    for file_path in files_with_jpg:
        print(file_path)
else:
    print("No .txt files containing '.jpg' were found.")